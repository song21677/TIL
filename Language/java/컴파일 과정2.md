## 프로그램과 프로세스
* 소스 파일을 컴파일, 링크하면 실행파일이 만들어지고 이것을 프로그램이라 한다.
* 이 프로그램을 CPU에서 실행하기 위해선 메모리에 올라가야 하는데 메모리에 올라가 실행중인 프로그램을 프로세스라 한다.

## JVM 특징
* 스택 기반의 가상 머신
  * 대표적인 컴퓨터 아키텍처인 인텔 x86아키텍처, ARM 아키텍처와 같은 하드웨어가 레지스터 기반으로 동작하는 데 비해 JVM은 스택 기반으로 동작한다.
* 심폴릭 레퍼런스
  * 기본 자료형(primitive data type)을 제외한 모든 타입을 명시적인 메모리 주소 기반의 레퍼런스가 아니라 심폴릭 레퍼런스를 통해 참조한다.
  * 심볼릭 레퍼런스는 바이트 코드가 JVM에 올라가게 되면 실제 메모리 주소가 아니라 이름으로 객체의 주소를 찾는다.
* 가비지 컬렉션
  * 클래스 인스턴스는 사용자 코드에 의해 명시적으로 생성되고 가비지 컬렉션에 의해 자동으로 파괴된다.
* 기본 자료형을 명확하게 정의하여 플랫폼 독립성 보장
  * C/C++ 등의 전통적인 언어는 플랫폼에 따라 int형의 크기가 변한다. JVM은 기본 자료형을 명확하게 정의하여 호환성을 유지하고 플랫폼 독립성을 보장한다.
* 네트워크 바이트 오더
  * 자바 클래스 파일은 네트워크 바이트 오더를 사용한다. 인텔 x86아키텍처가 사용하는 리틀 엔디안이나, RISC 계열 아키텍처가 주로 사용하는 빅 엔디안 사이에서 플랫폼 독립성을 유지하려면 고정된 바이트 오더를 유지해야 하므로 네트워크 전송 시에 사용하는 바이트 오더인 네트워크 바이트 오더, 빅 엔디안을 사용한다.
  * 
## 컴파일 과정
1. 개발자가 Java Source(.java)를 작성한다. <br><br>
2. Java Compiler가 자바 소스파일을 JVM이 이해할 수 있는 Java Byte Code(.class)로 컴파일한다. 바이트 코드의 각 명령어는 1바이트 크기의 Opcode와 추가 피연산자로 이루어져 있다. <br><br>
3. 컴파일된 바이트 코드를 JVM의 클래스로더(Class Loader)에게 전달한다. <br><br>
4. 클래스로더는 동적로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data area)인 JVM의 메모리에 올린다. <br><br>
   * 클래스 로더 세부 동작
      1. **로드**: 클래스 파일을 가져와 JVM의 메모리에 로드한다.
      2. **검증:** 자바 언어 명세(Java Language Specification) 및 JVM 명세에 명시된 대로 구성되어 있는지 검사한다.
      3. **준비**: 클래스가 필요로 하는 메모리를 할당한다. (필드, 메서드, 인터페이스 등등)
      4. **분석**: 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.
      5. **초기화**: 클래스 변수들을 적절한 값으로 초기화한다. <br><br>
 5. 실행엔진(Execution Engine)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행한다. 하나의 OpCode를 가져와 피연산자와 작업을 수행한 다음, 그 다음 OpCode를 수행하는 식으로 동작하는데 바이트 코드를 바이너리 코드로 변경할 때 다음 두 가지 방식으로 변경한다. <br><br>
    1. 인터프리터: 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행한다. 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다는 단점을 가진다.
    2. JIT 컴파일러(Just-In-Time Compiler): 인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 바이너리 코드로 직접 실행하는 방식이다. 컴파일 속도는 더 느리지만 컴파일 후에 캐시에 저장되므로 한번 컴파일 하면 다음 실행엔 빠르게 수행된다. <br><br>
   
![{5875909D-874F-44F5-9C0F-4A5C8CA15EB4}](https://github.com/song21677/TIL/assets/55786368/68da4245-3817-45d0-9969-8b14fe6a29cd)

### Runtime Data Area (런타임 데이터 영역)
* **PC Register(PC 레지스터)**: PC(Program Counter) 레지스터는 현재 수행 중인 명령어의 주소(JVM 주소)를 가지며 스레드가 시작될 때 생성되며 각 스레드마다 하나씩 존재한다. <br><br>
* **JVM Stack(JVM 스택)**: 메서드 호출 시 생성되는 스레드 수행정보를 기록하는 Stack Frame이라는 구조체를 저장하는 공간이다. 메서드 정보, 지역변수, 매개변수, 연산 중 발생하는 임시 데이터를 저장한다. 예외 발생 시 printStackTrace() 메서드로 보여주는 Stack Trace의 각 라인 하나가 스택 프레임을 표현한다. PC 레지스터와 마찬가지로 스레드가 시작될 때 생성되며 각 스레드마다 하나씩 존재한다. <br><br>
* **Native Method Stack**(네이티브 메서드 스택): Java외의 언어로 작성된 네이티브 코드를 위한 스택이다. JNI(JAVA Native interface)를 통해 호출하는 C/C++ 등의 코드를 수행하기 위한 스택으로, native 메서드의 매개변수, 지역변수 등을 바이트코드로 저장한다. 언어에 맞게 스택이 생성된다. (C면 C스택, C++이면 C++스택 생성) <br><br>
* **Heap**(힙): 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 메모리 영역으로 New 명령어를 통해 생성한 참조형 변수를 저장한다. Garbage Collection 대상이다. JVM 성능 등의 이슈에서 가장 많이 언급되는 공간으로 힙 구성 방식이나 가비지 컬렉션 방법 등은 JVM 벤더들의 재량이다. <br><br>
* **Method Area**(메서드 영역): 모든 스레드가 공유하는 영역으로 JVM이 시작될 때 생성된다. JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메서드에 대한 정보, Static 변수, 메서드의 바이트 코드 등을 보관한다. (문자열을 저장하는 literal pool에 저장한다.)<br><br>
* **Runtime Constant Pool**(런타임 상수 풀): JVM 동작에서 가장 핵심적인 역할을 수행하는 곳으로 JVM명세에서도 따로 중요하게 기술한다. 각 클래스와 인터페이스의 상수 뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블로 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조한다. <br><br>
* **예시**
  getList, insertList, updateList, deleteList CRUD 메소드가 있는 ListController class가 있을 때 이 클래스와 메소드의 정보는 실행엔진에 있는 Method 영역에 올라가며, 클래스의 메소드 호출이 발생하면 Method 영역의 정보를 읽어 해당 메소드의 매개변수, 지역변수 리턴값 등이 Stack 영역에 올려 처리하게 된다. 그리고 메소드의 실행이 끝나면 Stack 영역에서는 자동으로 제거된다. 만약 메소드 내에 new 명령어로 생성한 참조형 변수가 있을 경우 해당 값은 Heap 영역에 저장되고 Stack 영역에는 이 Heap 영역의 값을 참조할 수 있는 메모리 주소 값만 저장하게 된다.

### 클래스 로더
* 자바 컴파일러가 변환해둔 .class 파일을 동적 로딩한다고 했다.
* 실행 엔진이 사용할 수 있도록 JVM 메모리에 적재하는 역할을 한다.
* 로딩, 링크, 초기화 단계를 진행한다.

#### 로딩(Loading)
* .class 파일을 바탕으로 JVM Method Area에 로드한다.
  * 메서드와 변수 그리고 Class, Interface, Enum을 구분해서 저장한다.
  * Fully-Quailified Class Name (ex. java.lang.Character$Subset) 형식으로 저장한다.
* 동적 로딩을 하기 때문에, static 변수나 사용하지 않는 클래스는 로드되지 않는다. 즉, 한번에 메모리에 모두 로드하는 것이 아니라 필요한 경우 동적으로 메모리에 로드한다는 뜻이다. 
* 로딩이 끝나면 해당 클래스 타입의 객체를 생성하여 메모리의 Heap 영역에 저장한다.

* 예를 들어 .class 파일에 Temp라는 클래스가 있다고 해도, 사용하지 않으면 로드하지 않는다. 사용 시점에서 로드한다.
* 클래스를 명시적으로 초기화 하지 않아도 클래스 내부에 있는 static 변수를 호출하면 해당 클래스도 함께 로드된다.
* 한 클래스를 사용할 때, 상속받고 있다면 부모 객체 먼저 로드한 뒤 자식 객체를 로드한다.
* 내부 클래스를 호출하는 상황에도 내부 클래스를 갖는 외부 클래스를 로드한다.
* static final 변수를 호출하면 해당 클래스는 로드되지 않는데 그 이유는 상수는 JVM의 Constant Pool에 따로 저장되어 관리되기 때문이다.
* static class 내부 클래스는 인스턴스를 생성할 때, 외부 클래스가 꼭 필요한게 아니기 때문에 외부 클래스를 로드하지 않는다. ??

### 링크
* 클래스 파일을 사용하기 위해 검증하는 과정이다.
  
  1. Verify(검증): 클래스가 자바 언어 명세 및 JVM 명세에 명시된 대로 구성되어 있는지 검사한다. 검증을 실패하면 런타임에러 java.lang.VerifyError를 발생시킨다.
   * 검증된 컴파일러가 만든 class 파일이 아닌, 제 3자가 수동으로 변경한 경우에도 검증을 실패한다. 따라서 악의적인 변경을 방지한다.
  2. Prepare(준비): 클래스가 필요로 하는 메모리를 할당하고 클래스의 필드, 메서드, 인터페이스를 나타내는 데이터 구조를 준비한다.
    * 메모리를 할당하고 static(정적) 필드가 기본값으로 초기화된다.
  3. Resolve(분석): 클래스의 상수 풀 내 모든 심볼릭 레퍼런스(메모리 번지가 아닌 이름에 의한 참조)를 실제 메모리 레퍼런스로 교체한다.

### 초기화
* 링크 단계에서 확보한 메모리 영역에 클래스의 static 변수를 명시된 값으로 할당한다.


### 클래스로더의 로딩 과정
1. JVM의 메서드 영역에 클래스가 로드되어있는지 확인하고, 로드되어 있다면 해당 클래스를 사용한다. 존재하지 않는 경우 클래스 로더에 로드를 요청한다.
   
2. 애플리케이션 클래스로더 -> 확장 클래스로더(플랫폼 클래스로더) -> 부트스트랩 클래스로더로 요청이 위임된다.


3. 부트스트랩 클래스로더는 jdk/jre/lib에 해당 클래스가 있는지 확인한다. 없으면 확장 클래스로더(플랫폼 클래스로더)에 위임한다.


4. 확장 클래스로더(플랫폼 클래스로더)는 jdk/jre/lib/ext에 해당 클래스가 있는지 확인하고 없으면 애플리케이션 클래스로더에 위임한다.


5. 애플리케이션 클래스 로더는 환경 변수로 지정된 class path에 해당 클래스가 있는지 확인하고 존재하지 않으면 ClassNotFoundException 예외를 발생시킨다.


6. Class Path (클래스 패스) : JVM이 시스템 모든 폴더를 검사할 수 없으므로 JVM에 파일 경로를 제공해야한다.



1. 부트스트랩 클래스로더


자바에서 기본적으로 제공하는 API 등과 같은 표준 JDK 클래스들을 로드한다.

jre/lib 디렉토리에 있는 핵심 라이브러리와 java.lang.Object, java.lang.ClassLoader 와 같은 최소한의 자바 클래스만을 로드한다.

부트스트랩 클래스 로더는 가장 상위 클래스 로더이므로, 운영체제에 맞게 C/C++와 같은 네이티브 코드로 쓰여있다.



2. 확장 클래스로더


jre/lib/ext나 환경변수 java.ext.dirs에 지정된 경로(확장 디렉토리)에서 클래스를 로드한다.

자바 9 이후부터는 확장 매커니즘이 제거되면서 클래스 이름이 ExtClassLoader 에서 PlatformClassLoader로 변경되었다.



3. 애플리케이션 클래스로더


클래스 패스로 지정한 경로에서 클래스를 로드한다.

쉽게 생각하면, 우리가 만든 .class 확장자 파일을 로드한다.



상위 클래스로더가 찾지 못한 클래스를 하위 클래스로더가 찾는 경우가 존재하게 되므로, 상위 클래스로더는 하위 클래스로드가 로드한 클래스를 볼 수 없다.


https://gyoogle.dev/blog/computer-language/Java/%EC%BB%B4%ED%8C%8C%EC%9D%BC%20%EA%B3%BC%EC%A0%95.html
  https://aljjabaegi.tistory.com/387
  https://steady-snail.tistory.com/67
  https://d2.naver.com/helloworld/1230
  https://inkyu-yoon.github.io/docs/Language/Java/ClassLoader

  https://inpa.tistory.com/entry/JAVA-%E2%98%95-JVM-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD-%EC%8B%AC%ED%99%94%ED%8E%B8

  
  for (int []e : arr) {
    for (v : e) {
        System.out.println(v);
    }
  }