# 페이징

## 1. 논리 주소와 물리 주소
**논리 주소**는 프로그램이 실행될 때 프로세스가 사용하기 위해 CPU가 생성한 주소이다. **물리 주소**는 메모리 상의 물리적인 주소를 의미한다.

물리 주소에 직접적으로 접근을 하지 못하며, **논리 주소를 통해 물리 주소에 접근할 수 있다.**

<br>

## 2. 가상 메모리
실행중인 프로세스가 가상의 공간을 참조하여 **마치 커다란 물리 메모리를 갖고 있는 것처럼 사용할 수 있도록 하는 것이다.** 주소는 실제 메모리 주소가 아닌 가상의 메모리 주소를 준다.

### 특징
- - -
* 각 프로세스당 메인 메모리와 동일한 크기로 하나씩 할당된다.
* 가상 메모리는 보조기억장치를 이용하며 프로세스의 일부만 메모리에 로드하고 나머지는 보조기억장치에 두는 형태이다.
* 메모리 관리 장치(MMU)에 의해 물리 주소로 변환되어 사용자가 맵핑이 어떻게 되는지 의식할 필요없이 알아서 가상 메모리를 활용하여 작업한다.
* 실제 메모리는 전혀 연속적이지 않지만, CPU는 연속적으로 사용하고 있다는 것을 보장받으며 정상적으로 수행한다.

<br>

## 3. 페이지와 프레임
* **페이지** : 가상 메모리를 동일한 크기로 나눴을 때, 각 공간을 페이지라 한다.
* **프레임** : 물리 메모리를 동일한 크기로 나눴을 때, 각 공간을 프레임이라 한다.
* **크기** : 페이지와 프레임의 크기는 동일하다. 주로 4KB를 사용한다. 또한, 크기를 나눌 때 코드, 데이터, 스택 등 구성 요소와 상관없이 분할한다.
* 페이지와 프레임에 번호를 붙인다.
* **페이지 테이블** : 페이지 번호와 프레임 번호를 1:1로 저장하는 페이지 테이블이 존재한다.

<br>

## 4. 페이징 기법
가상 메모리와 물리 메모리를 페이지 단위로 분할하고, 프로세스의 각 페이지를 물리 메모리의 프레임에 불연속적으로 할당하고 관리하는 기법이다.

1. 페이지, 프레임을 **동적 할당**해준다.
2. 논리주소로 데이터에 접근/저장하며(이때, CPU는 연속적인 주소값으로 명령을 내림.) MMU에 의해 **논리 주소를 물리 주소로 변환함**으로써 실제로 데이터를 접근/저장할 수 있다.
3. 페이지, 프레임을 **반환**해준다.
4. 페이지 테이블을 저장하고 검색하는 빠른 캐시로 
5. 페이지 번호가 페이지 테이블에 있는지, 옵셋이 페이지의 범위를 넘어가는지 확인함으로써 **메모리를 보호**해준다.
6. 물리 메모리에 할당된 페이지 테이블과 빈 프레임 리스트 생성 **관리 유지**해준다.
7. 컨텍스트 스위칭 때, PCB로부터 페이지 테이블의 물리주소를 CPU의 PTBR 레지스터에 로딩해준다. 
<br>

<details>
  <summary>그림 설명 </summary>

**2개의 프로세스의 페이지들이 물리 메모리 프레임에 할당되는 모습**
1. 메모리에 2개 이상의 프로세스가 올라간다.
2. 프로세스마다 페이지 테이블이 있다.

![{26BB23AB-416F-40C3-8D99-D3DF5953314D}](https://github.com/song21677/TIL/assets/55786368/c93559c1-fdd3-4fe1-8774-0accd3026a9a)


**프로세스의 페이지들이 물리 메모리 프레임에 할당되는 모습** <BR>
32bit 시스템이라 가정했을 때, 프로세스 주소 공간은 4GB이고 페이지의 크기는 4KB라고 가정한다. 
1. 프로세스 주소 공간의 코드 영역은 페이지 0 ~ 2에 걸쳐 있고 힙 영역은 페이지 3 ~ 4에 걸쳐있다. 스택은 사용자 공간의 맨 마지막 페이지를 사용하고 있다.
2. 프로세스는 총 6개의 페이지를 사용하고 있으며, 프로세스의 크기는 6 * 4KB = 24KB이다. (프로세스의 크기는 작은 데 주소 공간은 큰 것을 볼 수 있다,,,)
3. 페이지 테이블은 프로세스 주소 공간의 모든 페이지를 나타낼 수 있으며 현재 6개의 항목만 사용한다.
  
![{BD291ED2-A711-4690-B865-2F484E97EE40}](https://github.com/song21677/TIL/assets/55786368/16963143-81a5-4b2b-b3b4-ee2fdb25a256)

4. 프로세스의 힙 영역에 동적할당을 요청하면 논리 페이지 5를 할당, 물리 프레임은 2를 할당해준다.
   * ``char *p = (char *)malloc(200);`` 
   * **페이지 5의 논리주소** : 5 * 4KB = 20KB == 20480
   * **프레임 2의 물리 주소** : 2 * 4KB = 8192
   * 할당된 영역의 주소는 논리 주소로 반환된다.
5. 데이터 저장을 요청하면 MMU에 의해 논리 주소가 물리 주소로 변환되어 물리 메모리에 저장된다.
   * ``*p = 'a';``
   * 논리주소 20480에 데이터 저장 요청이 들어오면, 20480에서 8192로 변환되고, 물리 주소인 8192에 저장된다.
6. 페이지와 프레임에 데이터가 없다면 할당 받은 메모리의 반환 요청이 들어올 때 모두 반환된다.
   * ``free(p);``
7. 커널 코드도 논리 주소로 되어 있으며, 시스템 호출을 통해 커널 코드가 실행될 때 현재 프로세스의 페이지 테이블을 이용하여 물리 주소로 변환된다.

![{0D338403-9D8B-4C98-91B2-4929A815914E}](https://github.com/song21677/TIL/assets/55786368/10bda1bc-760d-422f-b8ac-c0bfd0b3452a)

</details>

<br>

## 5. MMU
1. 주소 변환: 재배치 레지스터(페이지 테이블)를 여러 개 사용해 각 페이지의 실제 주소로 변경해준다.
2. 보호
3. 공유

### 1. 주소 변환
- - -
CPU가 접근하는 **논리주소**는 2진수로 표현되고 m비트가 있다고 가정하면 **하위 n비트**는 **오프셋(offset)** 또는 **변위(displacement)** 라 하고 **상위 m-n비트**는 **페이지의 번호**에 해당한다. **(n=d, m=n=p)** <br>

**페이지 번호(p)**는 **페이지 테이블의 인덱스 값**이고, **p에 해당되는 테이블 내용**은 **메모리의 프레임 번호**이다. **변위(d)는 변하지 않는 값이다.**

<details>
   <summary>주소 변환 연습</summary>
   <h3>Page size = 16bytes, Page Table = 5,3,2,8,1,4일 때 논리 주소 50번지는 물리주소 몇 번지인가?</h3> <br>

1. CPU가 50번지에 접근하려 하면, 페이지 테이블의 정보를 읽기 위해 **논리 주소를 p와 d값으로 나눠야 한다.**
2. d는 페이지 크기에 따라 달라지는데, 현재 페이지 크기가  16byte이므로 d=4가 되고 0 ~ 16의 offset을 가질 수 있다.
3. 논리 주소는 50이며, 이진수로 나타내면 110010이다. d는 4이므로 뒤에서 4칸이 d에 해당되며 나머지 2칸이 p에 해당된다. **(50 = 110010, p - 11, d = 0010)**
4. p는 이진수 11이고, 십진수로 3이므로 페이지 3번에 해당하는 프레임 번호는 8이다.
5. 물리주소 f = 1000(8), d = 0010이므로 물리주소는 10000010이며 십진수로 130번지가 된다.
</details>

### 2. 보호 (Protection)
- - -
페이지 테이블에 r, w, x 비트를 추가해 보호한다. 쓰기 비트가 꺼져있는 페이지에 쓰기 작업을 시도하면 CPU에 인터럽트가 발생하여 ISR(Interrupt Service Routine)에서 강제로 해당 프로세스를 종료시킨다.

### 3. 공유 (Sharing)
- - -
같은 프로그램을 쓰는 복수 개의 프로세스가 있다면 프로세스 메모리 중 code 영역은 같을 것이다. code가 변하지 않는 프로그램일 때 (non-self-modifying code, reentrant code, pure code라 한다.) 하나의 code 영역을 복수 개의 프로세스가 공유하여 메모리 낭비를 줄일 수 있다.

<br>


## 6. TLB를 활용한 메모리 접근
정리 예정

<br>

## 7. 페이징에서의 단편화
### 외부 단편화
- - -
발생하지 않는다.

### 내부 단편화
- - -
발생한다.

1. 페이지의 크기가 1KB, 프로그램의 크기가 10000byte일 때 페이지를 10개 할당(10240byte)하며 마지막 페이지에 남은 240byte가 내부 단편화 영역인 것이다.
2. 페이지 크기가 작을수록 내부 단편화 영역은 줄어든다
3. 페이지 크기가 작아진다는 것은 페이지 수가 늘어난다는 의미이며 페이지 테이블의 크기가 늘어나 유지 비용이 많이 들 수 있다.

<br>

## Reference
* https://techmeditationcafe.tistory.com/5

* https://velog.io/@passion_man/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-9.-%ED%8E%98%EC%9D%B4%EC%A7%95-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC

* https://sycho-lego.tistory.com/10

* https://dar0m.tistory.com/269